from typing import Optional, TYPE_CHECKING, Tuple, List

from django.core import validators
from django.core.exceptions import ObjectDoesNotExist
from django.db import models
from django.db.models import QuerySet
from django.utils import timezone

CURRENT_YEAR = timezone.now().year
DATASET_CHOICES = (
    ('CEN', 'Decennial Census'),
    ('ACS5', 'ACS 5-year'),
    ('ACS1', 'ACS 1-year'),
)

if TYPE_CHECKING:
    from geo.models import AdminRegion


class CensusTableRecord(models.Model):
    """
    Represents a specific data record table in the census bureau's data.

    """
    table_id = models.CharField(max_length=15)

    dataset = models.CharField(
        max_length=4,
        choices=DATASET_CHOICES,
        default='CEN'
    )
    year = models.IntegerField(
        validators=[validators.MinValueValidator(2010),
                    validators.MaxValueValidator(CURRENT_YEAR)]
    )

    description = models.CharField(max_length=500)

    class Meta:
        index_together = ('table_id', 'dataset', 'year')
        unique_together = ('table_id', 'dataset', 'year')

    @property
    def value_table(self):
        return f'{self.table_id}E'

    @property
    def moe_table(self):
        return f'{self.table_id}M'

    @property
    def uid(self):
        return f'{self.dataset}:{self.year}:{self.table_id}'

    @property
    def value_table_uid(self):
        return f'{self.dataset}:{self.year}:{self.value_table}'

    @property
    def moe_table_uid(self):
        return f'{self.dataset}:{self.year}:{self.moe_table}'

    def __str__(self):
        return f'{self.table_id} ({self.dataset} {self.year})'

    def get_values_at_geog(self, geog: 'AdminRegion') -> (float, Optional[float]):
        try:
            value = CensusValue.objects.get(geog_uid=geog.uid, census_table_uid=self.value_uid).value
        except ObjectDoesNotExist:
            value = None
        try:
            moe = CensusValue.objects.get(geog_uid=geog.uid, census_table_uid=self.moe_uid).value
        except ObjectDoesNotExist:
            moe = None
        return value, moe

    @staticmethod
    def get_table_uids(records: QuerySet['CensusTableRecord']) -> Tuple[List[str], List[str]]:
        value_ids, moe_ids = [], []
        for record in records:
            value_ids.append(record.value_table_uid)
            if record.moe_table:
                moe_ids.append(record.moe_table_uid)
        return value_ids, moe_ids


class CensusValue(models.Model):
    """
    Stores a single (geography, table, value) tuple
    """
    # unique IDs generated by models. decouples the relationship between geographies
    geog_uid = models.CharField(max_length=100, db_index=True)
    census_table_uid = models.CharField(max_length=100, db_index=True)

    value = models.FloatField(null=True, blank=True)
    raw_value = models.CharField(max_length=20, null=True, blank=True)

    class Meta:
        index_together = ('geog_uid', 'census_table_uid',)
        unique_together = ('geog_uid', 'census_table_uid',)

    def __str__(self):
        return f'{self.census_table_uid}/{self.geog_uid} [{self.value}]'
